// Basic Data Structure Programming

// Part 1 - Why Dynamic data structure? 
// Part 2 - Introduction to Linked List
// Part 3 - More about Linked List and Displaying a Linked List
// Part 4 - Counting all the Nodes in a Linked list and Sum of all elements in the Linked List
// Part 5 - Finding Maximum in a Linked list and Searching in a Linked list
// Part 6 - Improving Searching in Linked List
// Part 7 - Inserting in a Linked list
// Part 8 - Inserting in a sorted linked list and Deleting from a linked list
// Part 9 - Checking if a Linked list is sorted 
// Part 10 - Removing duplicates from a Linked List
// Part 11 - Reversing Linked List
// Part 12 - Reversing Linked List using Sliding Pointers and recursive technique
// Part 13 - Concatenating and Merging two Linked List
// Part 14 - Check for Loop in Linked List
// Part 15 - Circular Linked List
// Part 16 - Insert and Display in a Circular Linked list
// Part 17 - Deleting from a Circular Linked List
// Part 18 - Doubly Linked List - Insertion 
// Part 19 - Doubly Linked List - Deletion
// Part 20 - Doubly Linked List - Reverse
// Part 21 - Circular Doubly Linked List
// Part 22 - Comparison of Linked list
// Part 23 - Comparison of Linked List and Array
// Part 24 - Finding Middle element of a linked list and Intersecting point of Two Linked list
// Part 25 - Sparse Matrix using Linked List
// Part 26 - Polynomial using Linked list
// Part 27 - Introduction to Stack and Stack using Array
// Part 28 - Stack using Linked list
// Part 29 - Parenthesis Matching
// Part 30 - Infix to Postfix Conversion
// Part 31 - Associativity and Unary Operator
// Part 32 - Infix to Postfix using Stack method 1
// Part 33 - Infix to Postfix using Stack Method 2
// Part 34 - Introduction to Queue ADT
// Part 35 - Queue using Single Pointer and Two Pointer
// Part 36 - Queue using Array and its drawback
// Part 37 - Circular Queue
// Part 38 - Queue using Linked list
// Part 39 - Double-ended queue - Dequeue
// Part 40 - Priority Queue
// Part 41 - Queue using two Stacks

// Advanced Data Structure Programming
// Part 1 - Trees ( Terminology )
// Part 2 -  Number of Binary Trees using N Nodes
// Part 3 - Height vs Nodes in Binary Tree
// Part 4 - Internal Nodes Vs External Nodes in Binary Tree
// Part 5 - Strict Binary Tree and Height vs Node of strict Binary Tree
// Part 6 - Internal vs External Nodes of Strict Binary Tree
// Part 7 - n-ary Trees
// Part 8 - Analysis of n-ary Trees
// Part 9 - Representation of binary Tree
// Part 10 - Linked Representation of Binary Tree
// Part 11 - Full vs Complete Binary Tree
// Part 12 - Strict vs Complete Binary Tree
// Part 13 - Binary Tree Traversals - method 1
// Part 14 - Binary Tree Traversals - method 2 and method 3
// Part 15 - Creating Binary Tree
// Part 16 - Preorder Tree Traversal
// Part 17 - Inorder Tree Traversal
// Part 18 - Iterative Preorder and Inorder
// Part 19 - Level Order Traversal
// Part 20-  Generating Tree from Traversal
// Part 21 - Height and count of Binary Tree
// Part 22 - Count Leaf Nodes of a Binary Tree
// Part 23 - Introduction to Binary Search Tree
// Part 24 - Searching in Binary Search Tree
// Part 25 - Inserting in a Binary Search Tree - Iterative
// Part 26 - Inserting in a Binary Search Tree - Recursive
// Part 27 - Creating Binary Search Tree
// Part 28 - Deleting from Binary Search Tree
// Part 29 - Generating BST from Preorder
// Part 30 - Drawbacks of Binary Search Tree
// Part 31 - Introduction to AVL Trees
// Part 32 - Inserting in AVL with Rotations
// Part 33 - General form of AVL Rotation
// Part 34 - Generating AVL Tree
// Part 35 - Deletion from AVL Tree with Rotations
// Part 36 - Height Analysis of AVL Tree
// Part 37 - 2-3 Trees
// Part 38 - 2-3-4 Trees
// Part 39 - Red Black Tree - Introduction
// Part 40 - Red Black Tree Creation
// Part 41 - Red Black Tree vs 2-3-4 Trees
// Part 42 - Red Black Tree - Deletion
// Part 43 - Introduction to Heap
// Part 44 - Inserting in a Heap
// Part 45 - Creating a Heap
// Part 46 - Deleting from Heap and Heap Sort
// Part 47 - Heapify - Faster Method for creating Heap
// Part 48 - Heaps as Priority Queue
// Part 49 - Introduction to Graphs
// Part 50 - Representation of Undirected Graphs
// Part 51 - Representation of Directed Graph
// Part 52 - Breadth First Search
// Part 53 - Depth First Search
// Part 54 - Spanning Trees
// Part 55 - Prim's Minimum Spanning Tree
// Part 56 - Kruskal's Minimum Spanning Tree
// Part 57 - Disjoint Subsets
// Part 58 - Asymptotic Notations Big oh, Omega, Theta

// Algorithms 
// Part 1 – Introduction to Algorithms and Backtracking
// Part 2 – N Queen Problem
// Part 3 – Knight’s Tour Problem
// Part 4 – Rat in a Maze Problem
// Part 5 – Subset Sum Problem
// Part 6 – Graph Coloring Problem
// Part 7 – Hamiltonian Cycle
// Part 8 – Sudoku Solver
// Part 9 – Prime Numbers after Prime P with sum S
// Part 10 – Permutations of a given String
// Part 11 – Print all possible paths from top left to bottom right of a m x n matrix.
// Part 12 – Introduction to Divide and Conquer
// Part 13 – Binary Search explored
// Part 14 – Merge Sort
// Part 15 – Quick Sort
// Part 16 – Strassen’s Matrix Multiplication
// Part 17 – Introduction to Dynamic Programming
// Part 18 – Longest Common Subsequence
// Part 19 – Longest Palindromic Subsequence
// Part 20 – 0/1 Knapsack Problem
// Part 21 – Subset Sum Problem
// Part 22 – Minimum Cost Path
// Part 23 – Coin Change Problem
// Part 24 – Kadane’s Algorithm
// Part 25 – Minimum Edit Distance
// Part 26 – Longest Increasing Subsequence
// Part 27 – Introduction to Greedy Algorithm
// Part 28 – Activity Selection Problem
// Part 29 – Kruskal’s Minimum Spanning Tree
// Part 30 – Prim’s Minimum Spanning Tree
// Part 31 – Boruvka’s Minimum Spanning Tree
// Part 32 – Dijkstra’s Shortest Path Algorithm
// Part 33 – Minimum cost to connect all cities
// Part 34 – Introduction to Pattern Searching
// Part 35 – Naive Pattern Searching
// Part 36 – KMP Algorithm
// Part 37 – Rabin-Karp Algorithm
// Part 38 – Boyer Moore Algorithm – Bad Character Heuristic
// Part 39 – Boyer Moore Algorithm – Good Suffix Heuristic
// Part 40 – Manacher’s Algorithm



